package technology.rocketjump.undermount.entities.ai.goap;

import com.alibaba.fastjson.JSONObject;
import technology.rocketjump.undermount.entities.SequentialIdGenerator;
import technology.rocketjump.undermount.environment.GameClock;
import technology.rocketjump.undermount.persistence.EnumParser;
import technology.rocketjump.undermount.persistence.SavedGameDependentDictionaries;
import technology.rocketjump.undermount.persistence.model.ChildPersistable;
import technology.rocketjump.undermount.persistence.model.InvalidSaveException;
import technology.rocketjump.undermount.persistence.model.SavedGameStateHolder;

import java.util.Objects;

public class QueuedGoal implements Comparable<QueuedGoal>, ChildPersistable {

	private Goal goal;
	private ScheduleCategory category;
	private GoalPriority priority;
	private long queueIndex;
	private double expiryTime;

	public QueuedGoal() {

	}

	public QueuedGoal(Goal goal, ScheduleCategory category, GoalPriority priority, GameClock gameClock) {
		this.goal = goal;
		this.category = category;
		this.priority = priority;
		this.queueIndex = SequentialIdGenerator.nextId();
		if (goal.expiryHours == null) {
			expiryTime = Double.MAX_VALUE;
		} else {
			expiryTime = gameClock.getCurrentGameTime() + goal.expiryHours;
		}
	}

	public Goal getGoal() {
		return goal;
	}

	public ScheduleCategory getCategory() {
		return category;
	}

	public GoalPriority getPriority() {
		return priority;
	}

	public long getQueueIndex() {
		return queueIndex;
	}

	public double getExpiryTime() {
		return expiryTime;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		QueuedGoal that = (QueuedGoal) o;
		return Objects.equals(goal, that.goal) &&
				category == that.category &&
				priority == that.priority;
	}

	@Override
	public int hashCode() {
		return Objects.hash(goal, category, priority);
	}

	/**
	 * This number needs to be big enough that it should always be bigger than the number of IDs generated by SequentialIdGenerator
	 * but smaller than MAX_INT * MAX_PRIORITY.rank (which is 8) + 1     i.e. LARGE_NUMBER * 9 should be < MAX_INT but still positive
	 */
	private static int LARGE_NUMBER = Integer.MAX_VALUE >> 3; // 268,435,455

	@Override
	public int compareTo(QueuedGoal other) {
		return other.calculatePriority() - this.calculatePriority();
	}

	private int calculatePriority() {
		return (int) ((priority.priorityRank * LARGE_NUMBER) - queueIndex);
	}

	@Override
	public void writeTo(JSONObject asJson, SavedGameStateHolder savedGameStateHolder) {
		asJson.put("goal", goal.name);
		asJson.put("category", category.name());
		asJson.put("priority", priority.name());
		asJson.put("queueIndex", queueIndex);
		if (expiryTime < Double.MAX_VALUE) {
			asJson.put("expiryTime", expiryTime);
		}
	}

	@Override
	public void readFrom(JSONObject asJson, SavedGameStateHolder savedGameStateHolder, SavedGameDependentDictionaries relatedStores) throws InvalidSaveException {
		this.goal = relatedStores.goalDictionary.getByName(asJson.getString("goal"));
		if (this.goal == null) {
			throw new InvalidSaveException("Could not find goal with name " + asJson.getString("goal"));
		}
		this.category = EnumParser.getEnumValue(asJson, "category", ScheduleCategory.class, null);
		if (this.category == null) {
			throw new InvalidSaveException("Could not find category by name " + asJson.getString("category"));
		}
		this.priority = EnumParser.getEnumValue(asJson, "priority", GoalPriority.class, null);
		if (this.priority == null) {
			throw new InvalidSaveException("Could not find priority by name " + asJson.getString("priority"));
		}
		this.queueIndex = asJson.getLongValue("queueIndex");
		Double expiryTime = asJson.getDouble("expiryTime");
		if (expiryTime == null) {
			this.expiryTime = Double.MAX_VALUE;
		} else {
			this.expiryTime = expiryTime;
		}
	}
}
